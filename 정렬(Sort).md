## Arrays.sort vs Collections.sort

백준 2751 정렬 문제를 풀다가 알게 되었다. 자바 라이브러리의 Arrays.sort를 쓰면 시간 초과가 나고 Collections.sort를 쓰면 성공이었다.

둘의 속도 차이가 왜 나는 건지 알아보다가 알게 된 내용이다.

찾아보니, 둘은 서로 다른 정렬 알고리즘으로 구현되어있다.

#### Arrays.sort : DualPivotQuickSort.sort
 - 듀얼 피봇 퀵 정렬은 일반 퀵 정렬과 다르게 피봇을 2개를 두고 3개의 구간을 만들어 퀵 정렬을 진행한다. 랜덤 데이터에 대해서 평균적으로 퀵 정렬보다 좋은 성능을 낸다고 알려져 있다.
 - 참고로 퀵 정렬은 pivot 주변에서 데이터 이동이 빈번하게 일어나기 때문에 참조 지역성이 높은 편이다.
 - 퀵 정렬에 대해서는 나중에 자세히 다시 한 번 정리하겠다.

#### Collection.sort : TimSort.sort
 - TimSort는 삽입 정렬과 합병 정렬을 결합하여 만든 정렬로, Java 7부터 표준 정렬 알고리즘으로 채택되어 사용되고 있다고 한다.
 - TimSort에 대해서는 추후에 자세히 알아보겠다.
 
 
### * 왜 서로 다른 알고리즘을 사용하는 가?

 => #참조 지역성#의 원리에 있다.
 
 참조 지역성이란? -> 동일한 값 또는 해당 값의 근처에 있는 스토리지 위치가 자주 액세스 되는 특성이다. 특정 구간과 그 구간의 근처에 자주 접근한다는 의미이다.
                     이 참조 지역성은 CPU의 캐싱 전략에 영향을 미친다.
                     CPU가 데이터를 액세스하며 해당 데이터 뿐만 아니라 인접한 메모리에 있는 데이터 또한 캐시 메모리에 함께 올려두기 때문이다.
                     
 
### 정렬의 실제 동작시간 = C * 시간복잡도 + a
  => a는 아주 작은 값이므로 무시해도 되고, C의 영향도가 중요한데 #참조 지역성이 이 C에 영향을 미친다#.
  Array는 연속적인 메모리 주소를 갖기 때문에 참조 지역성이 좋아 C의 값이 낮은 #퀵 정렬#을 이용하면 충분한 성능을 제공할 수 있다.
  
  하지만, Collection은 List 기준으로 봤을 때 메모리 간 인접한 ArrayList 뿐만 아니라 메모리적으로 산발적인 LinkedList도 함께 존재해 모든 Collection들에게 최소의 동작시간이 발생해야 한다.
  #메모리적으로 산발적#이면 참조 인접성이 좋지 않고 C의 값도 상대적으로 높기 때문에 속도 면에서 성능을 낼 수 없다.
  따라서, 전체를 작은 덩어리로 나누어 각각의 덩어리를 #삽입 정렬#로 정렬하고, 이 덩어리들을 병합하여 #병합 정렬#로 정렬하면 속도가 빨라지지 않을까라는 아이디어에서 출발한 TimSort를 이용하는 게 
  평균적으로 더 좋은 성능을 기대할 수 있다.
  

### 마무리
 결론적으로 보자면, 서로 다른 알고리즘을 쓰는 데에는 Array와 Collection 각각의 특성 때문이다. 오늘은 간단히 두 sort 함수의 속도 성능 차이에 대한 이유를 알고자 찾아보았다.
 더 깊게 들어가서, TimSort에 관한 자세한 내용은 https://d2.naver.com/helloworld/0315536 이 블로그를 참고했다.
