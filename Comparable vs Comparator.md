### Comparable vs Comparator

Array에서는 이차원 배열부터 직접 정의해 사용해야 하고, Collection에서는 객체때문에 직접 정의해 사용할 수 있다.

정렬 문제를 풀다가 객체를 정렬해야해서 Comparator를 이용해 문제를 해결했는데, 개념이 헷갈려서 제대로 정리해보고자 찾아보았다.


##### <공통점>
1. **객체**를 정렬할 때 사용한다.
  - 자바를 비롯한 대부분의 언어가 오름차순 정렬을 기본적으로 제공
  - 따라서 기본 타입은 기본적으로 비교가 가능하지만 **직접 구현한 객체는 정렬할 기준이 없다**.
  - 이로 인해 '객체'를 정렬할 기준을 명시해주기 위해 사용한다.
2. 대소비교 또는 두 수의 차이를 통해 정렬
  - **음수 : 순서를 바꾸지 않는다.
  - **양수 : 순서를 바꾼다.
3. 둘 다 **Interface**이다. 
  - 내부에 선언되어 있는 메소드를 무조건 구현해주어야 한다.
  - ( 여기서 알게 된 추가적인 사실 : JAVA 8 부터는 인터페이스에서도 일반 메소드(함수)를 구현할 수 있도록 변경되었다. -> 보통 default나 static으로 선언된 메소드이다.
      이 외의 메소드들은 추상 메소드이므로 반드시 재정의가 필요하다!
      * default : 재정의 가능, * static : 재정의 불가능)


##### <차이점>

###### [Comparable]
1. java.lang 패키지에 존재
2. **자기 자신**과 매개변수 객체를 비교한다.
3. compareTo 메소드만 구현하면 된다.
4. 익명 객체(클래스) 구현은 가능하나, 자기 자신과 비교하기 때문에 이렇게 되면 익명 객체와 비교할 수 밖에 없다. -> 비효율적이라 대체로 사용하지 않는다.
5. 고정된 하나의 정렬 기준에 오름차순으로 정렬할 때 많이 사용된다.


###### [Comparator]
1. java.util 패키지에 존재
2. **두 매개변수 객체**를 비교한다.
3. compare 메소드만 구현하면 된다.
4. **익명 객체(클래스)**를 사용한다. 
  - compare 메소드를 사용하려면 compare 메소드를 제공해주는 객체가 필요하다. -> 이렇게 의미없는 객체가 사용되어야 함.
  - 익명 객체를 사용하면 이러한 의미없는 객체 사용을 피할 수 있다.
5. 다양한 기준으로 정렬할 때 많이 사용된다.
  - 익명 객체 : 클래스 이름으로 정의되지 않은 객체
  - 익명 객체는 자유롭게 몇 개는 생성하여 사용할 수 있다.


##### 추가적인 내용
오늘 문제 풀 때는 범위가 -10억 ~ 10억 까지여서 정렬 할 때 뺄셈에서도 범위가 넘어가지 않아 고려해주지 않아도 됐지만

자칫하면 두 수의 차이로 정렬 할 때 음수의 뺄셈에 의해 underflow, overflow가 발생해 순서가 뒤바뀔 수 있다.

이 점을 항상 고려해야 하기 때문에 정렬 시 두 수의 차이보다 두 수의 대소 비교를 가지고 정렬 하는 것이 더 안전하다.
