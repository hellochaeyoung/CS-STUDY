#### 시작하며

웹 백엔드 개발자로 성장하기 위해서 필요한 선수지식을 다시 한 번 정리하는 과정이 필요하다고 생각됐다. 이미 알고 있는 내용도 많지만 잊어버린 부분도 있고 해서

처음부터 다시 정리하기 위해 강의를 통해 시작했다. 웹의 기초적인 지식과 Servlet, JSP부터 Spring MVC까지 어떻게, 왜 이런 방식으로 발전해왔는지 정리해보려한다.


##### 웹
HTTP 기반에서 모든 것이 동작함

![image](https://user-images.githubusercontent.com/55968079/162752092-6f459fec-097d-4e35-86ff-63e998c0e952.png)

클라이언트에서 요청을 보내면 그 요청은 인터넷을 통해 서버에 도착하고 서버는 요청에 맞는 응답을 다시 인터넷을 통해 클라이언트에게 전달한다!

##### 웹 서버와 웹 어플리케이션 서버

1. 웹 서버
   - HTTP 기반으로 동작
   - 정적 리소스를 제공하는 것을 주로 담당하며 기타 부가 기능도 제공
   - 정적(파일) HTML, CSS, JS, 이미지 등
   - Nginx, Apache

2. 웹 어플리케이션 서버(WAS)
   - 마찬가지로 HTTP 기반으로 동작
   - 프로그램 코드를 수행하여 어플리케이션 로직을 수행하여 동적 리소스를 제공
   - 동적 HTML, HTTP API(JSON)
   - 서블릿, JSP, 스프링 MVC
   - 정적 리소스도 제공 가능해 웹 서버의 기능도 포함
   - 톰캣, Jetty 등

* 실제 둘의 경계가 모호하지만 웹 서버는 정적 리소스 제공, WAS는 동적 리소스 제공에 더 특화되어 있다고 생각하면 된다.
* WAS는 정적 리소스 제공도 가능해 어플리케이션 로직까지 포함해 많은 기능을 수행할 수 있어 자칫 서버 과부하가 발생할 수 있다!
  (가장 비싼 어플리케이션 로직이 정적 리소스 때문에 수행에 어려움이 발생할 수 있고, WAS가 죽어버리면 오류 페이지 조차 띄울 수 없는 단점이 있다.)
* 따라서, 다음과 같은 구조로 웹 시스템을 구성하는 것이 바람직하다.

![image](https://user-images.githubusercontent.com/55968079/162754180-7e1d0b77-87b6-49d4-b0b6-e13b44b78ee0.png)

-> 필요한 리소스에 맞춰 각 서버를 증설하면 되므로 상황에 유연하게 대처할 수 있다.

-> 또한 웹 서버는 정적 리소스만 처리하기에 잘 죽지 않으므로 WAS에 문제가 생겼을 시 오류 페이지를 띄워 대처할 수 있다.


##### 서블릿

![image](https://user-images.githubusercontent.com/55968079/162754572-321d7f1e-8b3b-43e5-a581-4ba28b645573.png)

위와 같이 핵심 비즈니스 로직 처리에 필요한 데이터를 보내고 받기 위해 WAS에서는 위와 같은 수 많은 과정과 처리를 거쳐야 한다. 

모든 개발자가 동일한 로직을 위한 코드 구현을 반복해야하는 불편함을 해소하고자 핵심 비즈니스 로직외의 모든 전후단계를 도맡아 처리해 줄 무언가가 필요했다.

이것이 바로 **서블릿**이다!

![image](https://user-images.githubusercontent.com/55968079/162763862-064762e9-b0d1-4520-93f7-2cf5e0ffaa7b.png)


* HttpServletRequest : HTTP 요청을 편리하게 사용할 수 있게 해준다.
* HttpServletResponse : HTTP 응답을 편리하게 사용할 수 있게 해준다.

=> 이로 인해 개발자들은 HTTP 스펙(HTTP 메소드, url, ContentType 등)을 직접 파싱할 필요 없이 쉽게 사용할 수 있게 되었다.

* 서블릿 컨테이너
  - WAS 내에 위치하며, 서블릿 객체들을 생성, 호출, 생명주기 관리까지 담당한다.
  - 서블릿 객체는 싱글톤으로 관리되기 때문에 공유 변수 사용에 유의한다! -> 요청 마다 매번 서블릿 객체를 생성하는 것은 굉장히 비효율적이기 때문
  - **동시 요청을 위한 멀티 스레드 처리**를 지원한다. -> 따라서 개발자는 싱글 스레드 프로그래밍하듯이 하면 된다 ( 멀티스레드까지 직접 생각하지 않아도 됨!)

* 멀티 스레드
  서블릿 객체를 실제로 호출하는 것은 바로 스레드이다! -> 단일 스레드이면 하나의 요청이 끝날 때까지 다른 요청들은 대기하거나 거절당하기 때문에 웹 서비스 운영 측면에서 맞지 않다.
  
  따라서 멀티 스레드 환경에서 처리되며 요청마다 스레드가 생성된다. -> **동시 요청** 처리가 가능하지만 스레드 생성 비용이 매우 **비싸고**, **컨텍스트 스위칭 비용**이 발생한다.
  또한 스레드 생성에 **제한이 없기** 때문에 갑자기 엄청난 요청이 한꺼번에 들어올 때 서버 과부하로 서버가 죽어버릴 수 있다.
  
  => 이와 같은 단점을 해결하기 위해서 바로 **스레드 풀** 을 사용한다.
  
  ![image](https://user-images.githubusercontent.com/55968079/162764016-2564d713-bef7-4216-a636-6955a2e62748.png)

* 스레드 풀
  과도한 스레드 생성 및 종료 비용과 무한한 스레드 생성을 막기 위해 스레드 풀에 개발자가 설정한 스레드 개수만큼 **미리 생성**해 놓고 이것을 계속 **재사용**한다.
  
  만일 스레드 풀에 있는 모든 스레드가 다 사용 중이라면 이후에 들어온 요청들에 대해 **대기 또는 거절**로 처리할 수 있다.
  
  - **실무**에서는 그럼 어떻게 할까?
  
    실무에서 역시 WAS의 가장 중요 튜닝 포인트는 **최대 스레드 개수**라고 한다. 
    
    
    Max Thread 개수가 너무 적다면? -> 서버 리소스는 여유롭지만 클라이언트에서는 금방 응답이 지연된다.
    
    Max Thread 개수가 너무 많다면? -> CPU, 메모리 리소스 임계점 초과로 서버가 다운될 수 있다.
    
    
    => 클라우드 환경이라면 서버를 증설해 우선 대처하고 이후에 튜닝, 아니라면 평상시에 튜닝에 신경써야한다고 한다.
    => 이렇게 스레드 풀의 Max Thread의 적정 숫자가 굉장히 중요하므로 **성능 테스트**가 중요하다! -> nGrinder를 사용해 해볼 것.
    
    
##### HTTP API

* HTML이 아니라 **데이터**를 전달 -> 주로 JSON 형식을 사용

* 주로 다양한 시스템에서 호출하여 사용한다 -> 데이터만 주고받기 때문에 **앱, 웹 클라이언트, 서버 - 서버 간**에서 다양하게 연동되어 사용할 수 있다.


##### 자바 백엔드 웹 기술의 역사

1. 서블릿
   HTML 생성이 매우 어렵다. -> 자바 코드 내에서 일일이 수작업으로 HTML 태그를 작성해줘야 함 -> 굉장히 불편!!!!
   ![image](https://user-images.githubusercontent.com/55968079/162767440-c59f8231-3340-4549-9a7b-63c415d7ea72.png)

2. JSP
   HTML 생성은 편리하지만 HTML 내에 비즈니스 로직이 담긴 자바 코드까지 포함하기 때문에 너무 많은 역할을 담당하게 되고 코드가 마구 뒤섞여 유지보수하기 굉장히 힘들다.
   ![image](https://user-images.githubusercontent.com/55968079/162767803-41dc525b-6c81-4604-9b20-efefe5e3be44.png)
   ![image](https://user-images.githubusercontent.com/55968079/162767952-1767f423-4d9a-4b8e-b320-1b7c3a5cf985.png)

3. 서블릿 + JSP 조합의 MVC 패턴
   - 모델, 뷰, 컨트롤러로 역할을 나누어 구현하는 방법이다.
   - 이전과 비교해 HTML 생성도 간편하고 JSTL로 인해 자바 코드도 최대한 줄여 보기 깔끔해지고 서블릿에서는 비즈니스 로직만 처리하면 된다.
   
   <컨트롤러인 서블릿 코드>
  
   ![image](https://user-images.githubusercontent.com/55968079/162768728-3f943a23-f9be-45de-a3e7-4cfc4bb5566d.png)

   
   <뷰 코드>
   
   ![image](https://user-images.githubusercontent.com/55968079/162768823-bba32231-03e4-4bdf-a58f-ac4fb8b32246.png)


  (위 코드는 설명의 참고용일 뿐 둘의 코드의 연관성은 없다.)
  
  하지만 서블릿 코드에 계속 반복되는 코드(getParameter(..), 다른 서블릿 또는 뷰로 이동하기 위한 forward 코드 등)가 아직까지 존재하고 request와 response 객체가
  매번 사용되지 않는다는 점 등 아직까지 여러 개선할 점이 존재한다. 

4. 어노테이션 기반의 스프링 MVC
   위와 같은 한계를 극복하기 위해 MVC 프레임워크가 2000년대 ~ 2010년대까지 많이 개발되었지만 어노테이션 기반의 스프링 MVC가 출시되면서 가장 좋은 프레임워크로 자리매김했다.
   
   또한 이후 스프링 부트가 등장해 기존 스프링의 어려움(서버에 WAS 설치, 설정의 복잡함 등)을 보완하여 더 발전하게 되었다.
   
   
##### 마무리

대략적인 웹 백엔드 기술의 전반적인 과정을 정리해보았다. 왜 MVC 패턴이 생겨나게 되었는지 명확하게 알 수 있었고 이러한 과정을 통해서 발전해왔다는 것을 알게 되어 더 명확해졌다.

최종적으로 현재는 REST API 방식으로 웹 백엔드를 많이 구축하는데 왜 REST API가 가장 효율적인 방식인지도 강의를 들으며 깨달을 수 있었다. 

이후 계속 강의를 들으며 내용을 정리해가야겠다.

