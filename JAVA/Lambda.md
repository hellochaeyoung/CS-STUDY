# Lambda

## 1. 동작 파라미터 화

### (1) 정의 및 배경

- 말 그대로 동작을 파라미터 화 하는 것..!
- 우리는 보통 ‘값’ 을 파라미터 화 하는 것에 익숙해 져있다.
- 이 고전적인 생각에서 조금 벗어나 **동작 자체**를 파라미터 화 하여 전달할 시 조금 더 유연한 코드를 작성할 수 있어 여러 상황을 처리할 수 있다.
- 동작을 파라미터 화 하기 위해서는 **인터페이스**로 구현하여 사용할 수 있다.
- 각 기능을 수행할 인터페이스 구현체를 만들어 역할과 기능을 분리할 수 있지만 이것 또한 구현체를 계속 만들어야 한다는 점에서 불편함을 느낄 수 있다.
- 또한 ‘동작 파라미터 화’ 를 할 때 아무래도 값을 전달할 때 보다는 코드가 길어지기 때문에 최대한 간결하게 작성하여 전달하는 것이 핵심이라고 생각된다.
- 따라서 따로 구현체 클래스를 직접 만드는 것이 아닌 코드 내에서 바로 구현할 수 있는 방법에 **익명 클래스**와 **람다 함수 표현식**이 있다.
- 둘 중에 더 간결한 방법이 **람다 함수 표현식**이고 이것을 가장 많이 사용한다.

## 2. 함수형 프로그래밍

### (1) 정의 및 배경

- 람다를 알려면 왜 함수형 프로그래밍을 알아야 하는가?
    - 자바의 특징과 람다의 특징이 아예 다르기 때문이다.
    - 자바는 명령형 프로그래밍이지만 람다는 선언적 프로그래밍이다.
     - 명령형 프로그래밍 : 클래스에서 메소드를 정의, 필요할 때 메소드를 호출하는 명령하여 동작
     - 선언적 프로그래밍 : 데이터가 입력으로 주어지고 **그 데이터가 처리되는 과정을 정의**하는 것으로 동작
    - 위에서 요구사항에 더 유연하게 대처하기 위해서 값을 파라미터화 하는 것이 아닌 동작을 파라미터화 한다 하였다.
     - 이 개념이 선언적 프로그래밍과 상응하는 부분이라고 생각한다.
        

### (2) 특징

- 불변성
    - 수학적인 함수에서 가장 중요한 것!
    - **입력받은 값이 동일할 때 결과가 같아야 한다.**
    - 몇 번을 호출하든지 동일한 결과가 나와야 한다.
    - 만약 동일하지 않다면 함수형 프로그래밍이라고 할 수 없다.ㅏ
- 참조 투명성
- 일급 함수
- 게으른 평가?

## 3. 람다

### (1) 정의

- 메소드를 하나의 식으로 표현하는 선언적 프로그래밍의 방법
    - 직접 인터페이스를 구현하여 사용하는 방법보다 간단하다.
    - 자바의 기존 익명 클래스를 사용하는 방법보다 더 간단하게 표현할 수 있는 방법이다.
    - 단일 메소드 클래스의 인스턴스를 보다 간결하게 표현할 수 있다.
    - 바로 함수형 인터페이스의 추상 메소드의 코드를 작성하는 것이라 할 수 있다.

### (2) 특징

- 익명
    - 이름이 없다.
- 함수
    - 메소드가 아닌 **함수**이다.
    - 클래스의 종속된 메소드가 아닌 어느 곳에도 종속되지 않은 함수이다.
- 일급 객체
    - 매개 변수의 **인자**가 될 수 있다.
    - **반환값**이 될 수 있다.
    - **변수**로 사용할 수 있다. → **함수 자체를 변수로** 사용할 수 있다!
     - 기존 메소드는 메소드의 리턴값을 매개변수로 사용한 것이지 메소드 자체를 매개변수로 사용한 것이 아니다!
    
    - 이렇게 람다는 **다양한 값**이 될 수 있다.
    - 그렇다면, 람다의 타입은 대체 무엇일까? 라는 의문이 생겨난다.

### (3) 타입

- 람다의 타입은 무엇일까?
- 자바는 메소드를 단독으로 선언할 수 없다 → 메소드는 객체, 즉 클래스에 속한 멤버이기 때문
- 따라서 람다식은 단순히 메소드를 선언하는 것이 아니라 이 메소드를 가진 객체를 생성한다.
- 메소드를 가진 객체는 바로 **인터페이스**!
    - 인터페이스 변수 = 람다식;
    - **인터페이스의 익명 구현 객체**를 생성하는 것
    - 인터페이스는 객체를 생성할 수 없으므로 구현 클래스가 필요 → 람다식이 익명 구현 클래스를 생성하고 객체화한다.
    - 이 때, 람다식은 대입될 인터페이스의 종류에 따라 작성 방법이 달라지기 때문에 람다식이 대입될 인터페이스를 람다식의 **타겟 타입**이라 한다.
    - 람다식은 하나의 메소드를 정의할 수 있기 때문에 하나의 추상 메소드만 가진 함수형 인터페이스만을 사용하여 구현할 수 있다!

### (4) 주의할 점

- 오버라이딩을 피하는 것이 좋다.
    - 메소드 이름이 같고 파라미터만 다르게 하는 오버라이딩은 실행 도중 여러 개의 메소드 중 어느 것을 사용 해야 할 지 모호해 정상 동작하지 않을 수 있다.
     - 이름을 변경하거나
     - 매개변수의 casting 값을 명시해주기
- 람다 안에 코드 블럭은 피하는 것이 좋다.
    - one line이 가장 이상적인 표현인 람다이지만 그렇지 않을 경우도 많다.
    - 2라인 이상을 사용하는 것 보다 별도의 함수로 정의해 사용하는 것이 가독성 측면에서 더 좋다.

### (5) 람다 캡쳐링

- 람다 바디에서 자유 변수를 **참조**하는 행위
    - 자유 변수 : 람다식의 매개 변수가 아닌 외부에서 정의된 변수
- 자유 변수가 인스턴스 변수(클래스의 멤버 변수) 또는 정적(static) 변수일 경우 캡쳐링을 원활하게 수행할 수 있다.
- 하지만 지역 변수가 final 또는 effectively final일 경우 문제를 일으킬 수 있다.

- 자유 변수가 final 속성이 아닌 지역 변수일 경우
    - **지역 변수**는!!! 각 **스레드의 스택 영역**에 저장된다.
    - 각 스레드의 스택 영역은 공유되지 않는다.
    - 람다는 지역 변수가 존재하는 스택 영역에 직접 접근하는 것이 아닌 그 지역 변수를 자신이 속해있는 스레드의 스택 영역에 복사하여 사용한다.
    - 따라서 지역 변수가 존재하는 스레드가 종료되도 이미 복사한 값을 참조하면서 에러가 발생하지 않는다.
    - 하지만, 멀티 스레드 환경에서 동일한 람다식이 실행될 때 지역 변수의 값이 변한다면 이미 복사하여 사용 중인 여러 스레드에서 동기화 문제가 발생한다.
    - 따라서 지역 변수는 값이 변하지 않는 final 속성을 가져야 한다.
    - 참고)
     - 인스턴스 변수나 정적 변수, 객체들은 힙 영역에 위치한다.
     - 힙 영역은 스레드 간 공유되는 영역이기 때문에 람다식을 사용하는 스레드 입장에서는 항상 참조 가능하다.
    - 예제 코드
    - 단순 지역 변수 참조가 아닌 ++number와 같이 연산을 적용할 경우 스레드 간 동기화 문제에 의해 오류가 발생해 사용할 수 없다.
    - 다만 연산자가 아닌 (number + 1)과 같이 단순 연산할 경우는 변수의 값 자체가 바뀌는 것이 아니므로 정상 동작한다.
    - ArrayList와 같은 컬렉션은 new로 생성되는 객체이기 때문에 힙 영역에 생성된다. 따라서 스레드 간 공유하는 영역에 존재하는 데이터이기 때문에 참조 및 재할당에도 영향이 없어 정상 동작하지만 멀티 스레드 환경에서 자칫 문제가 발생할 수 있기 때문에 잘 사용하지 않는다.
    
    ```java
    package example;
    
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.List;
    
    public class Main {
    
        public static void main(String[] args) {
    
            int number = 10;
    
            List<Integer> list = new ArrayList<>();
    
            list.add(1);
            list.add(2);
    
            Runnable thread1 = () -> {
                //System.out.println(++number);
                list.add(3);
                list.add(5);
                System.out.println(list);
            };
    
            thread1.run();
    
            Runnable thread2 = () -> {
                //System.out.println(++number);
                list.add(4);
                System.out.println(list);
            };
    
            thread2.run();
    
    method1(1);
    
        }
    
        static void method1(int n) {
    
            String name = "hello";
    
            int count = 10;
    
            Runnable thread = () -> {
                System.out.println(count);
            };
    
            thread.run();
        }
    }
    
    ```
    

## 4. 함수형 인터페이스

### (1) 정의 및 특징

- **1개의 추상 메소드를 가지는 인터페이스**
- 람다식은 함수형 인터페이스를 기반으로만 작성 가능하다.
    - 왜냐면 하나의 함수 만을 구현할 수 있기 때문
- 자바는 함수형 프로그래밍 언어가 아니기 때문에 JAVA 8부터 함수형 인터페이스를 제공해 함수를 일급 객체처럼 사용할 수 있게 하였다.
- default 메소드나 static 메소드의 개수는 상관 없다.
- JAVA에서 람다에 활용할 수 있는 함수형 인터페이스를 이미 제공하고 있다.
    - 직접 구현하여 사용할 수도 있지만 **이미 제공하고 있는 인터페이스로 충분히 활용**하여 다 사용 가능하다.
    - Predicate, Consumer, Supplier,Function<T,R>, Comparator, Runnable, Callable
    - 각 인터페이스의 사용법은 직접 코드를 구현하면서 파악하는 게 빠를듯..!

## 5. 메소드 참조

- 정의
    - 메소드를 참조하여 매개 변수의 정보 및 리턴 타입을 알아내 람다식에서 불필요한 매개 변수를 제거하는 것을 말한다.
    - 람다식은 기존 메소드를 단순히 호출만 하는 경우가 많기 때문에 **더 간단하게** 코드를 작성할 수 있는 방법이다.
    - 기존 람다식 표현은 IDE에서 자동으로 메소드 참조 방식이 더 좋다는 것을 알려주므로 IDE를 통해 사용해 보면 될 것 같다.
- 예시

```java
// With lambda expression
Arrays.sort(rosterAsArray, (Person a, Person b) -> {
    return a.getBirthday().compareTo(b.getBirthday());
});

Arrays.sort(rosterAsArray,
        Comparator.comparing(Person::getBirthday)
);
```

이처럼 **메소드 참조**를 통해 더 간단하게 구현할 수 있다.

- 종류
    - 정적 메소드 참조
     - 객체 생성 없이 바로 참조 가능
     - [클래스::메소드]
    - 인스턴스 메소드 참조
     - 객체 생성 후 참조
     - [참조 변수(객체)::메소드]
    - 매개 변수의 메소드 참조
     - 람다식의 메소드 결과를 매개 변수로 참조하여 사용하는 것
     - 기존의 메소드 결과를 사용할 수 있는 것과 동일한 개념
    - 생성자 참조
     - (a, b) → new Student(a,b) ⇒ Student::new
     - 매개 변수로 들어오는 개수에 따라서 다른 생성자를 접근
