### 최소 신장 트리 (MST, Minimum Spanning Tree)

##### 1. 신장 트리란?
  - 사이클 없이 그래프 내의 모든 정점을 잇는 트리
  - 즉, 그래프에서 일부 간선을 선택해서 만든 트리 -> 한 그래프에서 여러 신장 트리가 나올 수 있다.
  - 필연적으로 트리 형태가 되기 때문에 간선의 개수는 (N-1)개 이다.
  - DFS, BFS, Kruscal 알고리즘, Prim 알고리즘 등으로 신장 트리를 구현할 수 있다.


##### 2. 최소 신장 트리란?
  - 가중치가 존재하는 그래프에서 사용된 간선들의 가중치의 합이 최소가 되는 신장 트리
  - 대표적으로 Kruscal, Prim 알고리즘으로 구현한다.


##### 3. Kruscal 알고리즘
  - **간선** 중심
  - 탐욕적인 방법을 이용하는 알고리즘으로, 전체 간선들 중에서 무조건 최소값의 가중치를 갖는 간선을 먼저 선택하는 방법 ( 이전에 구현된 신장 트리와 상관없이 )
  - 간선의 개수가 적을 때 효율적인 방법
  - 구현 방법
  
    (1) 각 간선들의 가중치를 오름차순으로 정렬한다. -> 가중치가 있을 때만 필요, PriorityQueue를 사용하면 자동으로 오름차순 정렬된다.
    
    (2) 사이클을 형성하는 지 판단한다.
    
        * 간선을 형성한 양 끝 노드의 부모가 같은지 먼저 판단한다.
        * 다른 경우에만 신장 트리에 추가한다.(union-find)
        * 필요한 값(ex. 가중치의 합)을 저장한다.
        
    (3) (2) 과정을 큐가 빌 때까지 반복한다.
    
    
##### 4. Prim 알고리즘
  - **노드** 중심
  - 시작점에서부터 신장 트리의 집합을 단계적으로 확장해 나가는 방법
  - 시작 노드에서 갈 수 있는 노드들 중 간선의 가중치가 최소인 간선을 선택하여 트리를 형성하는 방법
  - 노드의 개수가 적을 때 효율적인 방법
  - 구현 방법
  
    (1) 처음에는 임의의 한 노드만 큐에 추가한다. -> PriorityQueue를 사용하면 마찬가지로 간선의 가중치 오름차순으로 정렬된다.
    
    (2) 이미 방문한 노드가 아닌 경우에만 방문 처리를 해주고 필요한 값을 저장한다.
    
    (3) 해당 노드에 이어진 다른 노드들 중 사이클 방지를 위해 이미 방문한 노드를 제외하고 큐에 추가한다. -> 이 때 간선의 가중치 값은 생각하지 않아도 된다. -> PriorityQueue가 자동으로 정렬해주기 때문
    
    (4) (2), (3) 과정을 큐가 빌 때까지 반복한다.
