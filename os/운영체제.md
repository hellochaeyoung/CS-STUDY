##### 운영체제
시스템의 자원(CPU, 메모리)과 동작을 관리하는 **소프트웨어** -> 프로세스, 저장장치(RAM, HDD), 네트워킹, 사용자, 하드웨어를 관리

* RAM == 메모리!!!!
  메모리의 구조 : Code, Data, Stack, Heap
  - Code : 실행할 프로그램의 코드
  - Data : 전역 변수, 정적 변수 등
  - Stack : 메소드, 지역 변수, 매개 변수 등 - **컴파일 시 크기가 결정**
  - Heap : 런타임 중 동적으로 생성되는 객체들 - **런타임에 크기가 결정**


##### 프로세스와 스레드

* 프로세스란?
  실행 중인 프로그램을 말함, 각각의 독립적인 메모리 영역을 가진다!! -> 프로세스마다 메모리와 CPU를 할당받음!

* 스레드란?
  프로세스 안 실행 단위를 말함, 메모리의 **Code, Data,Heap 영역은 공유**하지만 **Stack 영역은 독립적**으로 가지고 있다!
  
  

##### CPU 스케줄러
CPU는 한 번에 하나의 프로세스만 실행 가능 -> 사람의 입장에서 봤을 때에는 여러 프로그램이 동시에 실행되는 것처럼 보이지만 실제로는 CPU가 번갈아가며 실행!

=> 따라서 준비큐에서 대기하고 있는 프로세스들에 대해 CPU를 할당하는 방법이 필요하다.

선점 vs 비선점
- 선점 : 앞서 실행 중인 프로세스가 끝날 때까지 기다리는 것이 아니라 중간에 자리를 뺏어버리는 것, SRT, RR
  - RR : Round Robin, 모든 프로세스에 균등하게 설정한 Time을 배분하여 적용해 처리
         Time, 즉 Time Slice(Time Quantumn)이 심하게 크면 FCFS와 다를 게 없고, 심하게 작으면 불필요한 Context Switch가 빈번하게 일어나 오히려 비효율적이다.
         가장 합리적인 Time을 설정하는 것이 중요!
- 비선점 : 앞서 실행 중인 프로세스가 끝날 때까지 기다리는 것, SJF, FCFS


##### 가상 메모리
CPU가 프로세스를 실행할 때 하드디스크에 저장되어 있던 프로그램 전체를 메모리에 올리고 실행하는 것이 아니다! 

메모리 영역이 한정적이기 때문에 **실행에 필요한 부분만 메모리에 올려놓고 나머지는 하드디스크에 보관하는 기법**을 가상 메모리라 한다.

이 때, 한 프로그램의 필요한 부분이 메모리에 연속적으로 위치하는 게 아니기 때문에 프로그램을 실행시키기 위해서 메모리의 어느 부분에 위치하고 있는 지에 대한 정보가 필요하다.

이 정보를 기록해 둔 것이 페이지 테이블!



##### 데드락
프로세스의 실행에 필요한 자원을 얻지 못해 다음 작업을 못하는 상태

데드락 발생 조건 : 무조건 이 4가지 조건이 다 충족되어야 데드락 상태라고 말할 수 있다!

1. 상호 배제 : 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
2. 점유 대기 : 최소한 하나의 자원을 점유하고 있으면서 다른 자원의 사용을 위해 대기한다.
3. 비선점 : 다른 프로세스에 할당된 자원을 도중에 빼앗아 올 수 없다.
4. 순환 대기 : p0 -> p1, p1 -> p2, .... pn -> p0 이런 식으로 순환된 형태로 점유한 자원을 요구해야한다.

