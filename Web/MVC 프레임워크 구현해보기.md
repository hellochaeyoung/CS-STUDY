## [시작하며]

Spring MVC가 현재의 모습으로 발전해오기까지 단 한 번에 이루어진 것이 아니라 여러 단계를 거쳐 발전해온 것을 알고있다. 

어느 부분이 얼마나 불편했고, 어떻게 개선하여 현재의 모습까지 오게 됐는지 그 과정을 직접 구현해보며 알아가보고자 한다.




### 1. 프론트 컨트롤러 패턴의 도입

* 프론트 컨트롤러 패턴의 도입 전

![image](https://user-images.githubusercontent.com/55968079/162913627-bb84e658-4031-491a-9520-7b858a6dbb06.png)


도입 전에는 쉽게 말해 WAS로 진입하는 입구가 따로 정해져있지 않기 때문에 **어느 곳에서나 접근이 가능**했다. 따라서 모든 요청이 **공통된 로직**을 갖고 있으면서 각 요청 만의
비즈니스 로직을 포함한 상태에서 요청을 처리할 컨트롤러에 접근했다.

이로 인해 반복되는 과정이 굉장히 많았고 비효율적이었다.

* 프론트 컨트롤러 패턴의 도입 후

![image](https://user-images.githubusercontent.com/55968079/162914074-1ce488d3-b932-41a5-b2e3-8b29eec8cc80.png)


도입 후, **프론트 컨트롤러**라는 입구가 생겨 공통된 로직을 묶을 수 있었고 각 요청의 비즈니스 로직만 처리하면 되는 구조로 발전하게 되었다.

또한, 도입 전에는 모든 컨트롤러가 서블릿이었지만 이제는 프론트 컨트롤러가 url에 직접 매핑되어 실행되고 이후 요청에 맞는 컨트롤러를 호출하기 때문에 모든 컨트롤러가
서블릿 객체가 아니어도 되는 구조가 되었다.

**[스프링 웹 MVC와 프론트 컨트롤러 : 스프링 웹 MVC의 핵심도 바로 이 프론트 컨트롤러이다! -> 스프링 웹 MVC의 DispatcherServlet이 바로 프론트 컨트롤러 패턴으로 구현되어 있다.]




### 2. MVC 프레임워크 Version 1


![image](https://user-images.githubusercontent.com/55968079/162915526-94965cf5-7803-44db-b641-019b64aefceb.png)


: 프론트 컨트롤러에서 URL 매핑 정보를 찾아 컨트롤러를 호출하여 비즈니스 로직을 처리하고 view인 jsp로 넘기기 위해 HttpServletRequest에 데이터를 세팅해 jsp forward한다.

  따라서 아직까지도 뷰에 넘겨주기 위한 **forward 코드가 중복**되기 때문에 이 부분을 개선할 수 있다.
  




### 3. MVC 프레임워크 Version 2


![image](https://user-images.githubusercontent.com/55968079/162916369-7d7c124b-a51a-4745-b8c0-f858e0f49dea.png)


: view로 데이터를 뷰에 넘기는 과정인 forward 코드를 분리하기 위해 jsp 파일로 이동하는 forward 기능을 포함한 MyView라는 클래스를 만들어 역할을 일임하고, 컨트롤러는 뷰의 절대경로를 세팅한 MyView 객체를 리턴하여 뷰를 렌더링할 수 있게 하였다.

  프론트 컨트롤러의 도입으로 인해 컨트롤러는 오로지 비즈니스 로직만을 처리 하는 데 집중할 수 있게 되었고 로직 처리 결과인 데이터를 HttpServletRequest에 세팅하고 뷰 렌더링 역할은 
  MyView 객체를 리턴함으로써 위임할 수 있게 되었다.
  
  하지만 여전히 각 컨트롤러는 HttpServletRequest, HttpServletResponse 객체를 가지고 있어 서블릿 종속성이 존재하고, MyView 객체 리턴 시 뷰의 절대경로에서도 중복되는 경로가 존재한다.
  
  이러한 부분들을 개선할 수 있다.




### 4. MVC 프레임워크 Version 3


![image](https://user-images.githubusercontent.com/55968079/162918637-3f48b8ba-5dc3-4520-b4bf-1c9a72dfb81d.png)


: 컨트롤러의 서블릿 종속성을 없애기 위해 핵심 데이터만 추출해 매개변수로 전달하고 HttpServletRequest 객체를 Model로 사용하는 대신 **Model과 뷰 논리 이름을 포함하는 ModelAndView 객체**를 만들어서 서블릿 종속성을 제거할 수 있다.

  또한 반복되는 뷰의 경로를 없애기 위해 컨트롤러는 뷰의 **논리 이름**만 반환하고 뷰의 실제 물리 위치경로는 **viewResolver가 대신 처리**하여 뷰를 렌더링할 수 있게 한다.
  
  
  
  
  
### 5. MVC 프레임워크 Vesion 4

버전3는 서블릿 종속성도 제거하고 viewResolver를 이용해 뷰의 절대 경로를 처리하는 등 역할이 잘 분리되어 개선된 프레임워크 구조이지만 여전히 개발자가 매번 ModelAndView 객체를 
생성해야 하는 번거로움이 있다. 

따라서 아예 프론트 컨트롤러에서 Model 객체를 생성해 넘겨주는 방식으로 하여 컨트롤러는 정말 **뷰의 논리 이름만을 반환**할 수 있게 한다면 구현하기에 더 간편할 것 같아 개선하였다.


![image](https://user-images.githubusercontent.com/55968079/162921561-de107f60-f298-41eb-9b9b-407a933ad70f.png)


이와 같이 Version3와 거의 차이점이 없지만 Model 객체를 매개변수로 넘겨줌으로써 컨트롤러는 데이터를 model에 넣어주고 렌더링 될 뷰의 논리 이름만 리턴하면 되어 훨씬 간단하고 명료해졌다.




### 6. MVC 프레임워크 Version 5

앞서 구현해본 1~4버전의 MVC 프레임워크는 한 가지 큰 단점이 있다. 바로 **한 가지 구조의 컨트롤러**만 사용할 수 있다는 것이다.

* 만약 개발자마다 사용하고 싶은 컨트롤러의 구조가 다르다면? -> 개발자1은 v3 컨트롤러를, 개발자2는 v4 컨트롤러를 사용하고 싶다면 이전 버전의 프레임워크 구조로는 대응이 불가능하다.

따라서 원하는 컨트롤러를 골라서 마음껏 연결해서 쓸 수 있게끔 도와주는 **어댑터**가 필요하다!!!

**어댑터 패턴**을 적용하여 이와 같은 한계점을 개선할 수 있었다.


![image](https://user-images.githubusercontent.com/55968079/162923281-1611fbdc-ea6d-418d-a4d6-436d870f0e22.png)


: 이전과 마찬가지로 프론트 컨트롤러는 핸들러 매핑 정보를 통해 어떤 컨트롤러가 호출되어야 할지 찾고, 현재 프레임워크 내에 여러 구조의 컨트롤러가 존재하기 때문에 핸들러 어댑터 목록에서
  필요한 컨트롤러를 호출할 수 있는 핸들러 어댑터를 찾는다. 
  
  **핸들러 어댑터는 컨트롤러를 호출하여 비즈니스 로직을 수행하게 하고** 리턴한 ModelView 객체를 통해 viewResolver를 호출해 MyView를 반환하고 뷰 렌더링을 하게 된다.
  
  이와 같이 어댑터 패턴을 적용하게 되면 여러 구조의 컨트롤러를 사용할 수 있게 되고 더 다양한 요청을 효율적으로 처리할 수 있게 된다.
  
  **인터페이스로 설계**함으로써 각 **역할과 구현이 명확하게 분리**되어 있고, 이로 인한 **다형성**과 **어댑터** 덕분에 **기존 구조를 유지하면서 프레임워크의 기능을 확장**할 수 있게 되었다!!
  
  즉, **유연하고 확장성 있게** 설계가 가능해졌다!
  
  



## [마무리]

MVC 프레임워크를 직접 구현해보니 Spring MVC의 구조를 더 명확하게 알 수 있게 된 것 같다. 지금 Spring에서 제공하고 있는 어노테이션 기반의 기능들의 내면에는 위와 같은 구조가
존재함을 알게 되니 더 깊게 이해할 수 있을 것 같다. 

인터페이스를 통한 설계가 굉장히 유연하게 대처가 가능하고 확장성있다는 것을 알고는 있었지만 많이 적용해보진 않았었다. 따라서 나의 현재 개인 프로젝트에 리팩토링 해봐야 되겠다는 생각이 들었다.




